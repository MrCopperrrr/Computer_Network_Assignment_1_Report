\part*{Chương 4: Hiện thực chương trình}
\addcontentsline{toc}{part}{Chương 4: Hiện thực chương trình}
%============================================================================

\section*{4.1. Môi trường và Công cụ}
\addcontentsline{toc}{section}{4.1. Môi trường và Công cụ}
Chương này trình bày chi tiết các khía cạnh kỹ thuật trong quá trình xây dựng hệ thống, bao gồm môi trường phát triển, công cụ sử dụng, cũng như mã nguồn then chốt hiện thực hai chức năng cốt lõi: \textbf{HTTP Server với Cookie Session} và \textbf{Ứng dụng Chat Hybrid (P2P + WebSocket)}.

\subsection*{4.1.1. Ngôn ngữ lập trình}

\begin{itemize}
    \item \textbf{Python 3.x}:  
    Được chọn làm ngôn ngữ chính cho phần \textbf{backend} bao gồm \texttt{Proxy}, \texttt{Backend}, \texttt{Tracker Server} và \texttt{Peer Client}.  
    Python cung cấp cú pháp trong sáng, thư viện chuẩn phong phú và khả năng xử lý mạng mạnh mẽ, giúp nhóm dễ dàng xây dựng từ tầng socket thấp mà vẫn đảm bảo hiệu năng và khả năng mở rộng.
    
    \item \textbf{HTML5, CSS3, JavaScript (ES6)}:  
    Dùng để xây dựng toàn bộ \textbf{frontend} — giao diện web của hệ thống.  
    Kết hợp HTML và CSS để tạo giao diện hiện đại, trong khi JavaScript đảm nhận phần logic tương tác thời gian thực.
\end{itemize}

\subsection*{4.1.2. Các thư viện Python chính sử dụng}

\begin{itemize}
    \item \textbf{socket}:  
    Thư viện nền tảng của Python, được sử dụng để xây dựng các kết nối mạng TCP cấp thấp. Đây là công cụ cốt lõi để hiện thực \texttt{HTTP Server}, \texttt{Proxy}, \texttt{Tracker} và các kết nối \texttt{P2P} giữa các peer.
    
    \item \textbf{threading}:  
    Được sử dụng để triển khai kiến trúc \textit{đa luồng} (multithreading). Mỗi server (Backend, Tracker, P2P) hoạt động trong luồng riêng, đảm bảo khả năng phục vụ đồng thời nhiều kết nối mà không làm nghẽn (blocking) luồng chính.
    
    \item \textbf{argparse}:  
    Cung cấp giao diện dòng lệnh (CLI) thân thiện, cho phép cấu hình linh hoạt các tham số như địa chỉ IP, port, hoặc đường dẫn file cấu hình khi khởi chạy server.
    
    \item \textbf{http.server} và \textbf{socketserver}:  
    Hai thư viện tiêu chuẩn được kết hợp để xây dựng một \textit{HTTP Server tuỳ chỉnh} bên trong \texttt{peer\_client.py}.  
    \texttt{socketserver} cung cấp khung xử lý socket đa luồng, trong khi \texttt{http.server} định nghĩa các lớp cơ sở giúp dễ dàng xử lý request và tạo response HTTP.
    
    \item \textbf{websockets}:  
    Thư viện hiện thực giao thức WebSocket trong Python, cho phép xây dựng kênh giao tiếp hai chiều (full-duplex) giữa backend và trình duyệt. Đây là nền tảng cho phần ứng dụng chat thời gian thực.
    
    \item \textbf{json}:  
    Dùng để \textit{serialize} và \textit{deserialize} dữ liệu giữa các module. JSON là định dạng truyền thông tin chính trong API Tracker và trong giao thức P2P.
    
    \item \textbf{functools.partial}:  
    Được sử dụng để “gắn” tham chiếu đối tượng \texttt{PeerClient} vào lớp \texttt{CustomHandler} trong HTTP Server một cách an toàn, giúp lớp xử lý request có thể truy cập và thao tác trực tiếp trên trạng thái nội bộ của client hiện tại.
\end{itemize}

\subsection*{4.1.3. Công cụ phát triển phía Client (Trình duyệt)}

\begin{itemize}
    \item \textbf{WebSocket API}:  
    Được hỗ trợ sẵn trong các trình duyệt hiện đại, cho phép JavaScript khởi tạo và quản lý kết nối WebSocket đến backend. Đây là cầu nối chính để gửi và nhận dữ liệu chat thời gian thực.

    \item \textbf{Fetch API}:  
    Được sử dụng để gửi các yêu cầu HTTP không đồng bộ (asynchronous requests), ví dụ như trong quá trình xác thực \texttt{/confirm-login} hoặc khởi tạo session cookie.

    \item \textbf{Developer Tools (F12)}:  
    Công cụ gỡ lỗi tích hợp trong trình duyệt — đặc biệt là:
    \begin{itemize}
        \item Tab \textbf{Console}: Quan sát log JavaScript và lỗi runtime.
        \item Tab \textbf{Network}: Theo dõi các request HTTP và luồng WebSocket.
        \item Tab \textbf{Application}: Kiểm tra cookie, sessionStorage và localStorage.
    \end{itemize}
\end{itemize}

%============================================================================
\section*{4.2. HTTP Server với Cookie Session}
\addcontentsline{toc}{section}{4.2. HTTP Server với Cookie Session}

Phần này trình bày chi tiết cách các chức năng trong đề bài đã được hiện thực, kèm các đoạn mã nguồn minh họa cho các giải pháp kỹ thuật đã áp dụng.  
Máy chủ HTTP cơ bản được xây dựng hoàn toàn bằng \texttt{socket} và \texttt{threading}, không sử dụng framework, giúp hiểu rõ cơ chế hoạt động của HTTP ở mức nền tảng.  
Logic xử lý request được đóng gói trong lớp \texttt{HttpAdapter} (file \texttt{daemon/httpadapter.py}), trong khi việc khởi tạo server và quản lý luồng được triển khai trong \texttt{daemon/backend.py}.

\subsection*{4.2.1. Khởi tạo Server và Xử lý Đa luồng}

Nền tảng của máy chủ là khả năng xử lý nhiều kết nối đồng thời. Hàm \texttt{run\_backend} chịu trách nhiệm lắng nghe kết nối mới và tạo luồng riêng biệt cho mỗi client.  

\textbf{Đoạn mã: Khởi tạo server và tạo luồng mới cho mỗi client trong \texttt{daemon/backend.py}}

\begin{lstlisting}[language=Python, caption={Khởi tạo server và xử lý đa luồng}]
def run_backend(ip, port, routes):
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        server.bind((ip, port))
        server.listen(50)
        print("[Backend] Listening on port {}".format(port))

        while True:
            conn, addr = server.accept()
            client_thread = threading.Thread(
                target=handle_client,
                args=(ip, port, conn, addr, routes)
            )
            client_thread.daemon = True
            client_thread.start()

    except socket.error as e:
        print("Socket error: {}".format(e))
\end{lstlisting}

\subsection*{4.2.2. Xử lý Yêu cầu Đăng nhập (Task 1A)}

Khi người dùng gửi yêu cầu POST đến \texttt{/login}, hàm \texttt{handle\_login} trong \texttt{HttpAdapter} sẽ được gọi để phân tích dữ liệu form, kiểm tra thông tin đăng nhập và thiết lập cookie nếu hợp lệ.  

\textbf{Đoạn mã: Logic xử lý đăng nhập và thiết lập cookie trong \texttt{daemon/httpadapter.py}}

\begin{lstlisting}[language=Python, caption={Xử lý đăng nhập và tạo cookie}]
def handle_login(self, req, resp):
    raw_body = req.body.decode("utf-8", "ignore")
    creds = {}
    for pair in raw_body.split("&"):
        if "=" in pair:
            k, v = pair.split("=", 1)
            creds[k] = v

    if creds.get("username") == "admin" and 
        creds.get("password") == "password":
        req.path = "/index.html"
        raw_response = resp.build_response(req)
        body = raw_response.split(b"\r\n\r\n", 1)[1]

        headers = {
            "Content-Type": "text/html; charset=utf-8",
            "Set-Cookie": "auth=true; Path=/",
        }
        return ("200 OK", headers, body)
    else:
        e = RESP_TEMPLATES["login_failed"]
        return (e["status"], {"Content-Type": e["content_type"]}, 
            e["body"])
\end{lstlisting}

\subsection*{4.2.3. Kiểm soát Truy cập dựa trên Cookie (Task 1B)}

Để bảo vệ các tài nguyên nhạy cảm, hàm \texttt{cookie\_auth\_guard} được triển khai để kiểm tra tính hợp lệ của cookie trong mỗi request.  
Nếu không có hoặc cookie sai, người dùng sẽ bị chặn truy cập và nhận trang lỗi 401.

\textbf{Đoạn mã: Logic kiểm tra cookie trong \texttt{daemon/httpadapter.py}}

\begin{lstlisting}[language=Python, caption={Kiểm soát truy cập bằng cookie}]
def cookie_auth_guard(self, req):
    if req.path in ("/", "/index.html"):
        if req.cookies.get("auth") != "true":
            e = RESP_TEMPLATES["unauthorized"]
            return (e["status"], {"Content-Type": e["content_type"]}, 
                e["body"])

    if req.path == "/":
        req.path = "/index.html"

    return None
\end{lstlisting}

Thông qua các thành phần trên, hệ thống đã hoàn chỉnh chức năng của một \textbf{HTTP Server có quản lý phiên người dùng bằng Cookie Session}.

%============================================================================
\section*{4.3. Ứng dụng Chat Hybrid (Client-Server kết hợp P2P)}
\addcontentsline{toc}{section}{4.3. Ứng dụng Chat Hybrid (Client-Server kết hợp P2P)}

Nhiệm vụ này yêu cầu xây dựng một hệ thống chat hoàn chỉnh, kết hợp cả hai mô hình \textbf{Client-Server} và \textbf{Peer-to-Peer (P2P)}.  
Hệ thống được chia thành hai thành phần chính: \textbf{Tracker Server} (\texttt{start\_chatapp.py}) và \textbf{Peer Client} (\texttt{peer\_client.py}).

%----------------------------------------------------------------------------
\subsection*{4.3.1. Tracker Server – Trung tâm điều phối}

Tracker Server đóng vai trò là “bộ não” trung tâm của mạng lưới. Thành phần này được xây dựng dựa trên framework \texttt{WeApRous} được cung cấp sẵn.  
Nó sử dụng các biến toàn cục được bảo vệ bởi \texttt{threading.Lock} để đảm bảo an toàn khi nhiều luồng truy cập và ghi dữ liệu đồng thời.  
Các chức năng chính được hiện thực thông qua các API endpoint.

\textbf{Đoạn mã: Khai báo biến trạng thái và định nghĩa route trong \texttt{start\_chatapp.py}}

\begin{lstlisting}[language=Python, caption={Tracker Server - quản lý trạng thái mạng lưới}]
peers_list = []
channels_list = {}
users_credentials = { "admin": "password", "alice": "alice123", ... }

peers_lock = threading.Lock()
channels_lock = threading.Lock()

app = WeApRous()

@app.route('/submit-info', methods=['POST'])
def submit_info(headers="guest", body="anonymous"):
    try:
        data = json.loads(body)
        # ...
        with peers_lock: 
        # ...
        return json.dumps(response)
    except Exception as e:
        # ...
\end{lstlisting}
Đoạn mã trên minh họa cách \texttt{WeApRous} được dùng để định nghĩa endpoint một cách trực quan.  
Mỗi khi có yêu cầu \texttt{POST /submit-info}, hàm \texttt{submit\_info()} sẽ được gọi để xử lý.  
Khóa \texttt{peers\_lock} đảm bảo rằng việc cập nhật danh sách \texttt{peers\_list} là an toàn, ngay cả khi nhiều peer đăng ký cùng lúc.

%----------------------------------------------------------------------------
\subsection*{4.3.2. Peer Client – Kiến trúc Đa Server}

\texttt{PeerClient} là thành phần phức tạp nhất của hệ thống, được thiết kế như một tiến trình đa nhiệm có thể đảm nhiệm nhiều vai trò đồng thời.  
Khi được khởi động, hàm \texttt{start()} sẽ tạo ra ba luồng chạy song song, tương ứng với ba server độc lập:

\begin{itemize}
    \item \textbf{Server P2P} (\texttt{\_run\_p2p\_server}): Lắng nghe và chấp nhận các kết nối TCP từ các peer khác.
    \item \textbf{Server HTTP} (\texttt{\_run\_http\_server}): Phục vụ giao diện web \texttt{chat.html} và các tài nguyên tĩnh.
    \item \textbf{Server WebSocket} (\texttt{\_run\_websocket\_server}): Duy trì kênh giao tiếp thời gian thực giữa backend và trình duyệt.
\end{itemize}

\textbf{Đoạn mã: Khởi chạy ba server song song trong \texttt{peer\_client.py}}

\begin{lstlisting}[language=Python, caption={PeerClient - khởi chạy ba server đồng thời}]
class PeerClient:
    # ...
    def start(self):
        self.running = True
        
        p2p_thread = threading.Thread(target=self._run_p2p_server, 
            daemon=True)
        p2p_thread.start()

        http_thread = threading.Thread(target=self._run_http_server, 
            daemon=True)
        http_thread.start()

        ws_thread = threading.Thread(target=self._run_websocket_server, 
            daemon=True)
        ws_thread.start()
\end{lstlisting}

Cấu trúc đa luồng này đảm bảo rằng giao diện người dùng có thể hoạt động mượt mà, trong khi các kết nối mạng được xử lý song song mà không làm nghẽn tiến trình chính.

%----------------------------------------------------------------------------
\subsection*{4.3.3. Giai đoạn Client-Server: Khám phá Peer}

Trong giai đoạn này, một \texttt{Peer Client} đóng vai trò là “Client”, gửi yêu cầu đến \texttt{Tracker Server} để đăng ký thông tin và khám phá các peer khác trong cùng kênh.

Quy trình được thực hiện trong hàm \texttt{join\_channel()}, gồm ba bước chính:

\begin{enumerate}
    \item Gửi yêu cầu \texttt{POST /submit-info} đến Tracker để thông báo việc tham gia kênh.
    \item Gửi yêu cầu \texttt{/get-list} để lấy danh sách các peer hiện đang trong cùng kênh.
    \item Với mỗi peer nhận được, khởi tạo một luồng kết nối TCP riêng (P2P).
\end{enumerate}

\textbf{Đoạn mã: Logic tham gia kênh và khám phá peer trong \texttt{peer\_client.py}}

\begin{lstlisting}[language=Python, caption={Tham gia kênh và khởi tạo kết nối P2P}]
def join_channel(self, channel):
    try:
        # ...

        print(f"[P2P Auto-Connect] Getting peers for channel '{channel}'...")
        peers_in_channel = self.get_peer_list(channel=channel)
        
        for peer in peers_in_channel:
            if peer.get("username") != self.username:
                connect_thread = threading.Thread(
                    target=self.connect_peer,
                    args=(peer.get("username"), peer.get("ip"), peer.get("port"))),
                    daemon=True
                )
                connect_thread.start()
        return True
    except Exception as e:
        # ...
\end{lstlisting}

Việc sử dụng luồng riêng cho mỗi kết nối đảm bảo rằng quá trình khám phá và kết nối nhiều peer không gây treo giao diện hoặc nghẽn mạng.

%----------------------------------------------------------------------------
\subsection*{4.3.4. Giai đoạn Peer-to-Peer: Giao tiếp trực tiếp}

Sau khi quá trình khám phá hoàn tất, các peer có thể giao tiếp trực tiếp với nhau mà không cần qua Tracker.  
Hàm \texttt{connect\_peer()} (bên chủ động) và \texttt{\_handle\_peer\_connection()} (bên bị động) hiện thực quy trình “bắt tay” (handshake) và thiết lập kết nối TCP ổn định.  
Mỗi kết nối P2P sau đó được gắn với một luồng riêng \texttt{\_listen\_to\_peer()} để lắng nghe tin nhắn đến.

\textbf{Đoạn mã: Vòng lặp lắng nghe tin nhắn P2P trong \texttt{peer\_client.py}}

\begin{lstlisting}[language=Python, caption={Lắng nghe tin nhắn từ peer khác}]
def _listen_to_peer(self, conn, peer_username):
    print(f"[P2P Listen] Started listening thread for '{peer_username}'.")
    conn.settimeout(10.0)  
    
    while self.running:
        try:
            data = conn.recv(4096)
            if not data:
                break  

            message = json.loads(data.decode('utf-8'))
            self._process_peer_message(message)

        except socket.timeout:
            continue
        except Exception as e:
            print(f"[P2P Listen] Connection error with '{peer_username}': {e}")
            break
\end{lstlisting}

Nhờ cơ chế này, hệ thống cho phép các peer gửi và nhận tin nhắn trong thời gian thực mà không cần máy chủ trung gian, đạt được mục tiêu \textbf{kết hợp mô hình Client-Server và P2P trong cùng một ứng dụng}.

%============================================================================
\section*{4.4. ``Put It All Together'' – Tích hợp Hệ thống Hoàn chỉnh}
\addcontentsline{toc}{section}{4.4. ``Put It All Together'' – Tích hợp Hệ thống Hoàn chỉnh}
Nhiệm vụ này yêu cầu kết hợp các kỹ năng đã học từ việc xây dựng \textbf{HTTP Server (Task 1)} và các thành phần của \textbf{Ứng dụng Chat Hybrid (Task 2)} để tạo ra một hệ thống thống nhất, liền mạch và có trải nghiệm người dùng hoàn chỉnh. Hệ thống được hiện thực thông qua kiến trúc ba lớp rõ ràng:
\begin{itemize}
    \item \textbf{Backend Logic (Python)} – xử lý nghiệp vụ mạng và giao tiếp P2P.
    \item \textbf{Kênh Giao tiếp Real-time (WebSocket)} – cầu nối hai chiều giữa backend và giao diện.
    \item \textbf{Giao diện Người dùng (JavaScript)} – cung cấp trải nghiệm trực quan và tương tác.
\end{itemize}

\subsection*{4.4.1. Tích hợp Giao diện Web và Backend Logic}

Thay vì hoạt động như một ứng dụng dòng lệnh (CLI), tệp \texttt{peer\_client.py} được nâng cấp để đóng vai trò \textbf{server backend} phục vụ cho giao diện web. Mục tiêu của việc tích hợp này là:
\begin{itemize}
    \item Cung cấp trải nghiệm người dùng trực quan, hiện đại.
    \item Giải quyết giới hạn bảo mật của trình duyệt (trình duyệt không thể trực tiếp mở socket TCP).
\end{itemize}

\subsubsection*{HTTP Server tùy chỉnh}
Thành phần HTTP Server trong \texttt{peer\_client.py} không chỉ đơn thuần phục vụ file HTML tĩnh, mà còn chủ động \textit{``tiêm dữ liệu cấu hình''} (\textit{injection}) vào file \texttt{chat.html} trước khi gửi đến trình duyệt. Dữ liệu này giúp giao diện web nhận biết được thông tin khởi tạo (ví dụ: \texttt{username}, \texttt{peerPort}) để bắt đầu giao tiếp với backend.

\begin{lstlisting}[language=Python, caption={Logic truyền dữ liệu vào HTML trong \texttt{peer\_client.py}}, label={lst:inject}]
def do_GET(self):
    if self.path == '/www/chat.html' or self.path == '/':
        # ...
        injected_data = {
            "username": self.server.peer_client_ref.username,
            "peerPort": self.server.peer_client_ref.peer_port
        }
        content = content.replace(
            '<script id="config-placeholder"></script>',
            f'<script>window.PEER_CONFIG = {json.dumps(injected_data)};</script>'
        )
\end{lstlisting}

\subsubsection*{WebSocket – Cầu nối hai chiều giữa giao diện và backend}

WebSocket đóng vai trò là \textbf{cầu nối thời gian thực} giữa trình duyệt và backend Python. Khi người dùng gửi tin nhắn, JavaScript không truyền trực tiếp qua mạng, mà gửi một lệnh dạng chuỗi (\texttt{send}) đến backend thông qua WebSocket. Backend sau đó xử lý logic P2P, gửi tin nhắn đến các peer khác, rồi đẩy phản hồi trở lại trình duyệt.

\begin{lstlisting}[caption={Gửi lệnh từ giao diện đến backend qua WebSocket}, label={lst:send-js}]
function sendMessage() {
    const text = messageInput.value.trim();
    const command = `send ${currentChatTarget} ${text}`;
    sendCommand(command); 
}
\end{lstlisting}

\begin{lstlisting}[language=Python, caption={Xử lý lệnh gửi tin nhắn trong backend Python}, label={lst:send-py}]
def _handle_ui_command(self, cmd):
    parts = cmd.strip().split()
    command = parts[0].lower()
    if command == "send":
        username = parts[1]
        message = " ".join(parts[2:])
        self.send_peer(username, message)  
\end{lstlisting}

\subsection*{4.4.2. Kết hợp Quản lý Session (Cookie và localStorage)}

Để đáp ứng yêu cầu ``HTTP Cookies work'' trong Task 1 và đồng thời đảm bảo trải nghiệm người dùng liền mạch, hệ thống kết hợp cả hai cơ chế lưu trữ phía client: \textbf{Cookie} và \textbf{localStorage}.

\subsubsection*{Cookie}
Sau khi người dùng đăng nhập thành công, JavaScript gửi một yêu cầu \texttt{fetch('/confirm-login')}. Phía backend sẽ phản hồi với header \texttt{Set-Cookie}, minh chứng khả năng xử lý cookie của server HTTP. Mặc dù cookie này không tham gia vào logic chat thực tế, sự xuất hiện của nó trong trình duyệt (tab \texttt{Application} $\rightarrow$ Cookies) xác nhận rằng chức năng đã được hiện thực đúng chuẩn.

\subsubsection*{localStorage – Quản lý phiên thực tế}
Cơ chế lưu trữ chính của ứng dụng là \texttt{localStorage}. Nó giúp duy trì trạng thái đăng nhập và tự động kết nối lại khi tải lại trang.

\begin{itemize}
    \item \textbf{Lưu Session}: Sau khi kết nối WebSocket thành công, JavaScript lưu thông tin phiên (\texttt{username}, \texttt{peerPort}, \texttt{websocketPort}) vào \texttt{localStorage}.
    \item \textbf{Tự động kết nối lại}: Khi tải lại trang, script sẽ kiểm tra \texttt{localStorage}. Nếu tồn tại session hợp lệ, hệ thống bỏ qua bước đăng nhập và kết nối lại tự động.
    \item \textbf{Xóa Session}: Khi backend dừng hoạt động, session sẽ bị xóa để đảm bảo tính bảo mật.
\end{itemize}

\begin{lstlisting}[caption={Kiểm tra và tự động kết nối lại bằng localStorage trong \texttt{chat.html}}, label={lst:session}]
document.addEventListener('DOMContentLoaded', () => {
    const savedSession = localStorage.getItem('chatSession');
    if (savedSession) {
        const session = JSON.parse(savedSession);
        if (window.PEER_CONFIG && session.username === window.PEER_CONFIG.username) {
            console.log('Found matching session. Auto-connecting...');
            currentUser.username = session.username;
            connectWebSocket(session.websocketPort);
        }
    }
});
\end{lstlisting}

Tổng thể, sự kết hợp giữa \textbf{Python Backend}, \textbf{WebSocket}, \textbf{Cookie} và \textbf{localStorage} giúp ứng dụng đạt được cả hai mục tiêu:
\begin{enumerate}
    \item Đáp ứng các yêu cầu kỹ thuật của từng nhiệm vụ riêng lẻ.
    \item Cung cấp một hệ thống chat phân tán hoạt động ổn định, tiện dụng và có tính thực tiễn cao.
\end{enumerate}

