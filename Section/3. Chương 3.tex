\part*{Chương 3: Phân tích và thiết kế hệ thống}
\addcontentsline{toc}{part}{Chương 3: Phân tích và thiết kế hệ thống}
%============================================================================

\section*{3.1. Kiến trúc tổng thể}
\addcontentsline{toc}{section}{3.1. Kiến trúc tổng thể}
Hệ thống được thiết kế theo một kiến trúc đa thành phần, phân tách rõ ràng các vai trò và trách nhiệm nhằm đảm bảo tính module, dễ bảo trì và khả năng mở rộng. Sơ đồ dưới đây minh họa mối quan hệ và luồng tương tác giữa các thành phần chính của hệ thống.

% Chèn hình minh họa ở đây
% \begin{figure}[H]
%     \centering
%     \includegraphics[width=0.8\textwidth]{images/architecture_diagram.png}
%     \caption{Sơ đồ kiến trúc tổng thể của hệ thống}
%     \label{fig:architecture}
% \end{figure}

Kiến trúc này gồm ba thành phần chính, mỗi thành phần có vai trò riêng nhưng phối hợp chặt chẽ với nhau:

\subsection*{3.1.1. Tracker Server}
Đây là thành phần trung tâm, hoạt động như một trung tâm điều phối trong giai đoạn Client-Server. Nó là một tiến trình độc lập, lắng nghe trên một port cố định và có các vai trò chính sau:
\begin{itemize}
    \item \textbf{Quản lý định danh và xác thực:} Tracker Server duy trì cơ sở dữ liệu người dùng đơn giản (\texttt{users\_credentials}) và cung cấp API \texttt{/login} để xác thực danh tính của các peer khi tham gia mạng.
    \item \textbf{Quản lý trạng thái peer:} Tracker giữ danh sách động (\texttt{peers\_lock}) của tất cả peer đang trực tuyến, bao gồm username, địa chỉ IP và port P2P. Việc đăng ký và cập nhật thông tin được thực hiện qua API \texttt{/submit-info}.
    \item \textbf{Quản lý kênh chat:} Tracker Server quản lý danh sách các kênh và thành viên thông qua API \texttt{/add-list}.
    \item \textbf{Hỗ trợ khám phá peer (Peer Discovery):} API \texttt{/get-list} cho phép peer truy vấn và lấy danh sách các peer khác, làm tiền đề cho việc thiết lập kết nối P2P.
\end{itemize}

\subsection*{3.1.2. Peer Client}
Đây là thành phần cốt lõi và phức tạp nhất, được thiết kế như một tiến trình daemon chạy trên máy của người dùng. Mỗi peer client thực hiện đồng thời ba vai trò:
\begin{itemize}
    \item \textbf{Vai trò Client (với Tracker):} Chủ động kết nối TCP đến Tracker Server để xác thực, đăng ký thông tin và tham gia kênh.
    \item \textbf{Vai trò Server P2P:} Mở một socket TCP trên port do người dùng chỉ định (\texttt{peer\_port}) và lắng nghe các kết nối từ các peer khác.
    \item \textbf{Vai trò Server giao diện (UI Server):} Chạy trên một luồng riêng, gồm:
    \begin{itemize}
        \item \textbf{HTTP Server:} Chạy trên port \texttt{http\_port = peer\_port + 10000}, phục vụ file \texttt{chat.html} và tài nguyên tĩnh (CSS, hình ảnh), đồng thời cung cấp endpoint \\\texttt{/confirm-login} để thiết lập cookie.
        \item \textbf{WebSocket Server:} Chạy trên port \texttt{websocket\_port = peer\_port + 20000}, mở kênh giao tiếp hai chiều thời gian thực với giao diện web, nhận các lệnh từ người dùng và đẩy cập nhật tin nhắn lên trình duyệt.
    \end{itemize}
\end{itemize}

\subsection*{3.1.3. Giao diện người dùng (Web UI)}
Đây là lớp hiển thị của ứng dụng. Nhiệm vụ của nó gồm:
\begin{itemize}
    \item \textbf{Hiển thị trạng thái:} Hiển thị danh sách kênh, danh sách peer và nội dung chat dựa trên dữ liệu được đẩy xuống qua WebSocket.
    \item \textbf{Thu thập tương tác người dùng:} Ghi nhận hành động gõ tin nhắn, nhấn gửi, chọn cuộc trò chuyện.
    \item \textbf{Gửi lệnh:} Chuyển hóa các tương tác thành lệnh đơn giản (ví dụ: \texttt{send bob hello world}) gửi đến peer client để xử lý.
    \item \textbf{Quản lý session phía client:} Lưu thông tin phiên, cho phép tự động kết nối lại khi tải lại trang, mang lại trải nghiệm liền mạch.
\end{itemize}

%============================================================================
\section*{3.2. Thiết kế các Module chính}
\addcontentsline{toc}{section}{3.2. Thiết kế các Module chính}

Hệ thống được cấu thành từ ba module chính, hoạt động độc lập nhưng tương tác chặt chẽ với nhau: \textbf{Tracker Server}, \textbf{Peer Client} và \textbf{Giao diện Web}. Thiết kế của mỗi module được tối ưu hóa cho vai trò cụ thể của nó.

\subsection*{3.2.1. Tracker Server}

Tracker Server được xây dựng như một dịch vụ API RESTful đơn giản bằng framework WeApRous. Nó quản lý trạng thái tập trung của toàn bộ mạng lưới P2P. Để đảm bảo an toàn dữ liệu khi nhiều peer truy cập đồng thời, các biến toàn cục như \texttt{peers\_list} và \texttt{channels\_list} được bảo vệ bằng \texttt{threading.Lock}.

Các API chính của Tracker Server bao gồm:

\begin{itemize}
    \item \textbf{API /login} \\
    Phương thức: POST \\
    Chức năng: Xác thực danh tính người dùng dựa trên \texttt{username} và \texttt{password}. \\
    Input (JSON Body):
    \begin{verbatim}
    {
        "username": "<tên>", 
        "password": "<mật khẩu>"
    }
    \end{verbatim}
    Output (JSON):

    \begin{itemize}
        \item Thành công:
        \begin{verbatim}
        {
        "status": "success", 
        "token": "token_<tên>"
        }
        \end{verbatim}
        \item Thất bại:
        \begin{verbatim}
        {
        "status": "failed", 
        "message": "Invalid credentials"
        }
        \end{verbatim}
    \end{itemize}

    \item \textbf{API /submit-info} \\
    Phương thức: POST \\
    Chức năng: Cho phép một peer đăng ký hoặc cập nhật thông tin với Tracker, bao gồm các kênh tham gia. \\
    Input (JSON Body):
    \begin{verbatim}
    {
    "username": "<tên>", 
    "ip": "<địa chỉ IP>", 
    "port": <số port>, 
    "channels": ["<tên kênh>"]
    }
    \end{verbatim}
    Output (JSON):
    \begin{verbatim}
    {
    "status": "success", 
    "peer_id": <id>, 
    "total_peers": <số lượng>
    }
    \end{verbatim}

    \item \textbf{API /add-list} \\
    Phương thức: POST \\
    Chức năng: Cho phép peer thông báo tham gia một kênh chat mới. \\
    Input (JSON Body):
    \begin{verbatim}
    {
    "username": "<tên>", 
    "channel": "<tên kênh>"
    }
    \end{verbatim}
    Output (JSON):
    \begin{verbatim}
    {
    "status": "success", 
    "channel": "<tên kênh>", 
    "members": ["<thành viên>"]
    }
    \end{verbatim}

    \item \textbf{API /get-list} \\
    Phương thức: GET hoặc POST \\
    Chức năng: Cung cấp danh sách các peer đang trực tuyến, có thể lọc theo kênh. \\
    Input (JSON Body, tùy chọn):
    \begin{verbatim}
    {} 
    hoặc 
    {"channel": "<tên kênh>"}
    \end{verbatim}
    Output (JSON):
    \begin{verbatim}
    {
    "status": "success", 
    "peers": [{"username": ..., "ip": ..., "port": ...}]
    }
    \end{verbatim}
\end{itemize}

\subsection*{3.2.2. Peer Client}

Peer Client là module phức tạp nhất, được thiết kế để chạy như một tiến trình nền đa nhiệm. Khi \texttt{peer\_client.py} được thực thi, hàm \texttt{start()} sẽ khởi tạo ba server độc lập, mỗi server chạy trên một luồng riêng để tránh block lẫn nhau:

\begin{itemize}
    \item \texttt{\_run\_p2p\_server}: mở socket TCP trên \texttt{peer\_port}, lắng nghe kết nối P2P từ các peer khác.
    \item \texttt{\_run\_http\_server}: mở TCPServer trên \texttt{http\_port}, phục vụ giao diện web \texttt{chat.html} và xử lý các yêu cầu HTTP đặc biệt như tạo cookie.
    \item \texttt{\_run\_websocket\_server}: mở server WebSocket trên \texttt{websocket\_port}, sẵn sàng nhận kết nối từ giao diện web để giao tiếp hai chiều.
\end{itemize}

\subsection*{3.2.3. Luồng kết nối P2P (Handshake)}

Quy trình thiết lập kết nối trực tiếp giữa hai peer (ví dụ Alice và Bob) được thiết kế theo cơ chế "handshake":

\begin{enumerate}
    \item \textbf{Alice (khởi tạo):} Gọi hàm \texttt{connect\_peer} để tạo socket TCP mới và gửi request connect đến Bob.
    \item \textbf{Bob (lắng nghe):} Hàm \texttt{\_handle\_peer\_connection} nhận kết nối, đọc tin nhắn đầu tiên.
    \item \textbf{Alice gửi handshake:} Gửi JSON:
    \begin{verbatim}
    {"type": "handshake", "username": "alice"}
    \end{verbatim}
    \item \textbf{Bob phản hồi:} Nhận handshake, lưu socket và gửi JSON:.
    \begin{verbatim}
    {"type": "handshake_ack", "username": "bob"}
    \end{verbatim}
    \item \textbf{Alice nhận ACK:} Xác nhận kết nối thành công, lưu socket.
    \item \textbf{Bắt đầu lắng nghe:} Mỗi kết nối tạo luồng \texttt{\_listen\_to\_peer} để nhận tin nhắn tương lai.
\end{enumerate}

\subsection*{3.2.4. Giao diện Web (chat.html)}

Giao diện được thiết kế như một \textit{Single-Page Application} (SPA) đơn giản, nhận dữ liệu từ \texttt{peer\_client.py}.

\begin{itemize}
    \item \textbf{Tải trang và tự động điền:} Peer Client truyền username và peer\_port vào HTML. JavaScript điền form tự động.
    \item \textbf{Tự động kết nối (Session):} Kiểm tra \texttt{localStorage}. Nếu tìm thấy phiên hợp lệ, bỏ qua màn hình đăng nhập và tự khởi tạo WebSocket.
    \item \textbf{Kết nối thủ công:} Nếu không có session, người dùng nhập thông tin, nhấn "Connect", lưu session và mở WebSocket.
    \item \textbf{Giao tiếp qua WebSocket:}
    \begin{itemize}
        \item \textbf{Gửi lệnh:} Hành động người dùng (ví dụ gõ tin nhắn) được đóng gói thành lệnh dạng chuỗi và gửi qua WebSocket.
        \item \textbf{Nhận dữ liệu:} JavaScript lắng nghe sự kiện \texttt{onmessage} để nhận tin nhắn mới hoặc danh sách peer cập nhật.
        \item \textbf{Cập nhật giao diện:} Dựa trên loại dữ liệu, các hàm \texttt{displayMessages}, \\\texttt{updatePeerList} cập nhật giao diện liên tục.
    \end{itemize}
\end{itemize}


%============================================================================
\section*{4.3. Thiết kế Giao thức}
\addcontentsline{toc}{section}{4.3. Thiết kế Giao thức}
Để các thành phần của hệ thống có thể giao tiếp và hiểu lẫn nhau, hai giao thức ứng dụng đơn giản đã được thiết kế dựa trên các kênh truyền TCP và WebSocket.

\subsection*{4.3.1. Giao thức P2P giữa các Peer}

Giao thức này được sử dụng để trao đổi dữ liệu trực tiếp giữa các tiến trình \texttt{peer\_client.py}. Toàn bộ dữ liệu được đóng gói dưới dạng JSON và gửi qua kết nối TCP. Mỗi thông điệp JSON đều chứa trường \texttt{type} để xác định mục đích của nó.

Các loại thông điệp chính:

\begin{itemize}
    \item \textbf{Handshake} \\
    Mục đích: Peer khởi tạo kết nối gửi thông điệp này để tự giới thiệu và bắt đầu quá trình "bắt tay". \\
    Định dạng JSON:
\begin{verbatim}
{
    "type": "handshake",
    "username": "<tên của người gửi>"
}
\end{verbatim}

    \item \textbf{Handshake Ack} \\
    Mục đích: Peer nhận kết nối phản hồi lại handshake, xác nhận kết nối đã được chấp nhận. \\
    Định dạng JSON:
\begin{verbatim}
{
    "type": "handshake_ack",
    "username": "<tên của người phản hồi>"
}
\end{verbatim}

    \item \textbf{Chat} \\
    Mục đích: Gửi tin nhắn riêng tư đến một peer cụ thể. \\
    Định dạng JSON:
\begin{verbatim}
{
    "type": "chat",
    "from": "<tên người gửi>",
    "channel": "direct",
    "message": "<nội dung tin nhắn>",
    "time": "<dấu thời gian ISO 8601>"
}
\end{verbatim}

    \item \textbf{Broadcast} \\
    Mục đích: Gửi tin nhắn đến một kênh chat (ví dụ: \texttt{general} hoặc \texttt{broadcast}). Peer gửi sẽ lặp qua tất cả các kết nối P2P hiện có. \\
    Định dạng JSON:
\begin{verbatim}
{
    "type": "broadcast",
    "from": "<tên người gửi>",
    "channel": "<tên kênh>",
    "message": "<nội dung tin nhắn>",
    "time": "<dấu thời gian ISO 8601>"
}
\end{verbatim}
\end{itemize}

\subsection*{4.3.2. Giao thức WebSocket giữa UI và Backend}

Giao thức này được thiết kế để giao tiếp giữa giao diện web (\texttt{chat.html}) và tiến trình \\\texttt{peer\_client.py}. Nó hoạt động theo mô hình \textit{command-based}, trong đó UI gửi các lệnh dạng văn bản thô, và backend trả về các thông điệp JSON.

\subsubsection*{Lệnh từ UI đến Backend (JavaScript → Python)}

Các lệnh được gửi dưới dạng chuỗi, phân tách bằng khoảng trắng:

\begin{itemize}
    \item \texttt{login <username> <password>}: Xác thực với Tracker Server.
    \item \texttt{join <channel\_name>}: Tham gia một kênh chat.
    \item \texttt{list}: Lấy danh sách peer mới nhất từ Tracker.
    \item \texttt{connect <username> <ip> <port>}: Kết nối thủ công đến một peer (dành cho gỡ lỗi/nâng cao).
    \item \texttt{send <username> <message>}: Gửi tin nhắn riêng.
    \item \texttt{sendchannel <channel\_name> <message>}: Gửi tin nhắn đến một kênh.
\end{itemize}

\subsubsection*{Thông điệp từ Backend đến UI (Python → JavaScript)}

Backend gửi các thông điệp JSON để UI dễ phân tích và cập nhật giao diện:

\begin{itemize}
    \item \textbf{Kết quả đăng nhập}
\begin{verbatim}
{
    "type": "login_result",
    "result": {"status": "success", "token": ...}
}
\end{verbatim}

    \item \textbf{Danh sách Peer}
\begin{verbatim}
{
    "type": "peer_list",
    "peers": [{"username": ..., "ip": ..., "port": ...}, ...]
}
\end{verbatim}

    \item \textbf{Tin nhắn Chat hoặc Broadcast} \\
    Chuyển tiếp nguyên vẹn thông điệp JSON nhận được từ peer khác:
\begin{verbatim}
{
    "type": "chat",
    "from": "bob",
    "message": "Hello Alice!",
    ...
}
\end{verbatim}

    \item \textbf{Thông báo hệ thống / Lỗi}
\begin{verbatim}
{
    "type": "system",
    "message": "P2P link established with bob."
}

{
    "type": "error",
    "message": "Connection to john timed out."
}
\end{verbatim}
\end{itemize}